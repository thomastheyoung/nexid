/**
 * NeXID Core - XID Implementation
 *
 * This module provides the core XID class implementation for globally unique identifiers
 * that are lexicographically sortable. Each XID consists of 12 bytes (96 bits) with the
 * following structure:
 *
 *   ╔═══════════════════════════════════════════════════════════════╗
 *   ║0             3║4             6║7             8║9            11║
 *   ║--- 4 bytes ---║--- 3 bytes ---║--- 2 bytes ---║--- 3 bytes ---║
 *   ║═══════════════════════════════════════════════════════════════║
 *   ║     time      ║   machine ID  ║   process ID  ║    counter    ║
 *   ╚═══════════════════════════════════════════════════════════════╝
 *
 * When encoded using base32-hex (characters 0-9 and a-v), it results
 * in a 20-character string that is:
 * - Lexicographically sortable (sorts naturally in databases)
 * - Chronologically sortable (time is the first component)
 * - URL-safe (uses only alphanumeric characters)
 * - Compact (20 characters vs 36 for UUID)
 *
 * @module nexid/core/xid
 */

import { Result } from 'nexid/types/result';
import { compareBytes, decode, encode, RAW_LEN } from './encoding';

// ============================================================================
// Constants
// ============================================================================

/** 16-bit mask for process ID */
export const PROCESS_ID_MASK = 0xffff;

/** 8-bit mask for byte operations */
export const BYTE_MASK = 0xff;

// ============================================================================
// XID Implementation
// ============================================================================

/**
 * Class representing an XID - a globally unique, lexicographically sortable identifier.
 *
 * An XID is a 12-byte value that encodes timestamp, machine ID, process ID, and counter
 * components to ensure uniqueness across distributed systems without coordination.
 */
export class XID {
  /** Internal byte array representing the XID */
  private readonly bytes: Uint8Array;

  /**
   * Create a new XID from raw bytes.
   *
   * @param bytes - Raw 12-byte array for the ID. If omitted, creates a nil (zero) ID.
   * @throws Error if bytes are provided but not exactly 12 bytes long
   * @example
   * ```typescript
   * // Create a nil ID
   * const nilId = new XID();
   *
   * // Create an ID from bytes
   * const bytes = new Uint8Array(12);
   * const id = new XID(bytes);
   * ```
   */
  constructor(bytes?: Uint8Array | null) {
    if (bytes && bytes.length === RAW_LEN) {
      // Make a copy to prevent external modification
      this.bytes = new Uint8Array(bytes);
    } else if (!bytes) {
      // Create a nil ID if no bytes provided
      this.bytes = new Uint8Array(RAW_LEN);
    } else {
      throw new Error(`ID must be exactly ${RAW_LEN} bytes`);
    }
  }

  // ============================================================================
  // Public Instance Methods
  // ============================================================================

  /**
   * Get the timestamp portion of this ID as a JavaScript Date object.
   *
   * @returns A Date object representing when this ID was created
   * @example
   * ```typescript
   * const id = new XID(bytes);
   * const creationTime = id.getTime();
   * console.log(creationTime.toISOString());
   * ```
   */
  public getTime(): Date {
    // First 4 bytes contain Unix timestamp (seconds since epoch)
    const seconds =
      (this.bytes[0] << 24) | (this.bytes[1] << 16) | (this.bytes[2] << 8) | this.bytes[3];
    return new Date(seconds * 1000);
  }

  /**
   * Get the machine identifier component from this ID.
   * This is a 3-byte value derived from platform-specific identifiers.
   *
   * @returns A 3-byte Uint8Array containing the machine ID portion
   */
  public getMachineId(): Uint8Array {
    return this.bytes.slice(4, 7);
  }

  /**
   * Get the process ID component from this ID.
   * This is a 2-byte value representing the process that generated the ID.
   *
   * @returns A number representing the process ID
   */
  public getProcessId(): number {
    return (this.bytes[7] << 8) | this.bytes[8];
  }

  /**
   * Get the counter component from this ID.
   * This is a 3-byte value that increments for each ID generated by the same
   * process, ensuring uniqueness even when multiple IDs are generated in the same second.
   *
   * @returns A number representing the counter value
   */
  public getCounter(): number {
    return (this.bytes[9] << 16) | (this.bytes[10] << 8) | this.bytes[11];
  }

  /**
   * Get a copy of the raw bytes of this ID.
   *
   * @returns A 12-byte Uint8Array containing the raw ID data
   */
  public toBytes(): Uint8Array {
    // Return a copy to prevent modification
    return new Uint8Array(this.bytes);
  }

  /**
   * Convert this ID to its 20-character string representation using base32-hex encoding.
   *
   * @returns A 20-character string representation of the ID
   * @example
   * ```typescript
   * const id = new XID(bytes);
   * const idString = id.toString(); // e.g. "cv37img5tppgl4002kb0"
   * ```
   */
  public toString(): string {
    return encode(this.bytes);
  }

  /**
   * Custom JSON serialization method that converts the ID to its string representation.
   * This enables convenient serialization when using JSON.stringify().
   *
   * @returns The string representation of the ID
   * @example
   * ```typescript
   * const id = new XID(bytes);
   * const json = JSON.stringify({ id }); // {"id":"cv37img5tppgl4002kb0"}
   * ```
   */
  public toJSON(): string {
    return this.toString();
  }

  /**
   * Compare this ID with another lexicographically.
   * Since the timestamp is the first component, this also sorts chronologically.
   *
   * @param other - The XID to compare against
   * @returns Negative number if this ID is smaller (older), 0 if equal, positive if this ID is greater (newer)
   * @example
   * ```typescript
   * if (id1.compare(id2) < 0) {
   *   console.log('id1 is older than id2');
   * }
   * ```
   */
  public compare(other: XID): number {
    return compareBytes(this.bytes, other.bytes);
  }

  /**
   * Check if this ID is equal to another object.
   * Two XIDs are equal if they contain the same bytes in the same order.
   *
   * @param other - The object to compare against
   * @returns True if the other object is an XID with identical bytes, false otherwise
   * @example
   * ```typescript
   * if (id1.equals(id2)) {
   *   console.log('IDs are identical');
   * }
   * ```
   */
  public equals(other: unknown): boolean {
    if (this === other) return true;
    if (!(other instanceof XID)) return false;

    // Compare all bytes
    for (let i = 0; i < RAW_LEN; i++) {
      if (this.bytes[i] !== other.bytes[i]) {
        return false;
      }
    }

    return true;
  }

  /**
   * Check if this is a nil (zero) ID.
   * A nil ID has all bytes set to zero and is typically used as a placeholder or default value.
   *
   * @returns True if this is a nil ID, false otherwise
   * @example
   * ```typescript
   * const id = new XID();
   * if (id.isNil()) {
   *   console.log('This is a nil ID');
   * }
   * ```
   */
  public isNil(): boolean {
    for (let i = 0; i < RAW_LEN; i++) {
      if (this.bytes[i] !== 0) {
        return false;
      }
    }
    return true;
  }

  // ============================================================================
  // Static Methods
  // ============================================================================

  /**
   * Creates an XID from a raw byte array.
   *
   * @param bytes - The 12-byte array to create the ID from
   * @returns A Result containing either the new XID or an error message
   * @example
   * ```typescript
   * const bytes = new Uint8Array(12);
   * const result = XID.fromBytes(bytes);
   * if (result.isOk()) {
   *   const id = result.unwrap();
   *   console.log(id.toString());
   * }
   * ```
   */
  public static fromBytes(bytes: Uint8Array): Result<XID> {
    if (bytes.length !== RAW_LEN) {
      return Result.Err(`XID must be exactly ${RAW_LEN} bytes`);
    }
    return Result.Ok(new XID(bytes));
  }

  /**
   * Parses an XID from its 20-character string representation.
   *
   * @param idString - The string to parse (expected to be 20 characters in base32-hex format)
   * @returns A Result containing either the parsed XID or an error message
   * @example
   * ```typescript
   * const result = XID.fromString('cv37img5tppgl4002kb0');
   * if (result.isOk()) {
   *   const id = result.unwrap();
   *   console.log(id.getTime());
   * } else {
   *   console.error(result.unwrapErr());
   * }
   * ```
   */
  public static fromString(idString: string): Result<XID> {
    try {
      const bytes = decode(idString);
      return Result.Ok(new XID(bytes));
    } catch (error) {
      return Result.Err((error as Error).message);
    }
  }
}
