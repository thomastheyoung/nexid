{
  "version": 3,
  "sources": ["../src/web.ts", "../src/env/lib/hash-function/subtle-crypto.ts", "../src/env/lib/machine-id/web-fingerprint.ts", "../src/common/constants.ts", "../src/env/lib/process-id/web.ts", "../src/env/lib/random-bytes/web-crypto.ts", "../src/core/encoding.ts", "../src/core/xid.ts", "../src/core/counter.ts", "../src/core/xid-generator.ts", "../src/env/lib/hash-function/@definition.ts", "../src/env/lib/machine-id/@definition.ts", "../src/env/lib/process-id/@definition.ts", "../src/env/lib/random-bytes/@definition.ts", "../src/env/registry.ts"],
  "sourcesContent": ["/**\n * @module nexid/index-web\n *\n * NeXID Web browser-specific entry point.\n *\n * ARCHITECTURE:\n * This module provides a browser-optimized entry point for the NeXID library,\n * pre-configured with the WebAdapter for client environments. This allows\n * for more efficient bundling in browser applications by avoiding the dynamic\n * environment detection process and eliminating Node.js-specific code.\n *\n * When imported directly, this module uses the WebAdapter without having\n * to detect the environment, providing a small performance benefit during\n * initialization and allowing for more aggressive tree-shaking of server-specific\n * code in bundlers.\n */\n\nimport { hash as subtleCryptoHash } from 'nexid/env/lib/hash-function/subtle-crypto';\nimport { getFingerprint } from 'nexid/env/lib/machine-id/web-fingerprint';\nimport { getProcessId } from 'nexid/env/lib/process-id/web';\nimport { randomBytes as webCryptoRandomBytes } from 'nexid/env/lib/random-bytes/web-crypto';\nimport { XID } from './core/xid';\nimport { XIDGenerator } from './core/xid-generator';\nimport { Environment, EnvironmentAdapter } from './env/registry';\nimport { initNeXID } from './types/api';\nimport { Generator } from './types/xid-generator';\n\nconst WebAdapter = new Environment({\n  RandomBytes: webCryptoRandomBytes,\n  HashFunction: subtleCryptoHash,\n  MachineId: getFingerprint,\n  ProcessId: getProcessId,\n} as EnvironmentAdapter);\n\n/**\n * Creates an XID generator with browser-specific optimizations.\n *\n * @param options - Optional configuration parameters\n * @returns Promise resolving to a fully configured XID generator\n */\nasync function createXIDGenerator(options?: Generator.Options): Promise<Generator.API> {\n  console.log('NeXID: initializing with Web adapter');\n  return XIDGenerator(WebAdapter, options);\n}\n\nexport { XID };\nexport type XIDGenerator = Generator.API;\nexport const init: initNeXID = createXIDGenerator;\nexport default { init: createXIDGenerator };\n", "/**\n * @module nexid/env/lib/hash-function/subtle-crypto\n * \n * Web Crypto API implementation of SHA-256 hashing.\n * \n * ARCHITECTURE:\n * This module provides an implementation of the HashFunction feature using\n * the Web Crypto API's SubtleCrypto interface. It creates a SHA-256 hash of\n * the input data, which is used to transform machine IDs and other identifiers\n * into a format that doesn't expose sensitive information.\n * \n * SECURITY:\n * - Uses the browser's native cryptographic implementation\n * - Provides a cryptographically secure hash for data protection\n * - Handles both string and binary input formats using TextEncoder\n */\n\nimport { FeatureSet } from 'nexid/env/registry';\n\n/**\n * Creates a SHA-256 hash of the input data using the Web Crypto API.\n * Automatically converts string input to UTF-8 byte array before hashing.\n * \n * @param data - String or byte array to hash\n * @returns Promise resolving to a 32-byte Uint8Array containing the hash\n */\nexport const hash: FeatureSet['HashFunction'] = async (data: string | Uint8Array) => {\n  if (typeof data === 'string') {\n    const encoder = new TextEncoder();\n    data = encoder.encode(data);\n  }\n  const buffer = await globalThis.crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(buffer);\n};\n", "/**\n * @module nexid/env/lib/machine-id/web-fingerprint\n * \n * Browser fingerprinting implementation for machine ID generation.\n * \n * ARCHITECTURE:\n * This module provides a privacy-respecting browser fingerprinting solution\n * for generating stable machine IDs in web environments. It collects various\n * browser characteristics that together can uniquely identify a device while\n * avoiding collection of personally identifiable information.\n * \n * The approach produces a reasonably consistent identifier across browser\n * sessions, which is then cryptographically hashed before use in XIDs.\n * \n * PRIVACY:\n * - No persistent storage is used (no cookies, localStorage, etc.)\n * - No canvas fingerprinting or other invasive techniques\n * - Does not collect personally identifiable information\n * - Only uses available browser APIs that don't require special permissions\n */\n\n/**\n * Generates a pseudo-fingerprint that includes an environment discriminator.\n * This produces a string containing various browser/device characteristics\n * that collectively provide a reasonably stable device identifier.\n * \n * @returns Promise resolving to a string containing fingerprint components\n */\nexport async function getFingerprint(): Promise<string> {\n  const components: string[] = [];\n\n  // Pseudo random salt\n  const salt = ((Math.random() * 0xffff) | 0).toString(16).padStart(2, '0');\n  const timestamp = Date.now().toString(36);\n  components.push(`salt: ${salt}:${timestamp}`);\n\n  // Environment discriminator\n  components.push(`env:${detectContext()}`);\n\n  // Navigator-based components.\n  if (exists(navigator)) {\n    components.push(`ua:${navigator.userAgent || ''}`);\n    components.push(`lang:${navigator.language || ''}`);\n\n    if (navigator.languages && Array.isArray(navigator.languages)) {\n      components.push(`langs:${navigator.languages.join(',')}`);\n    }\n\n    if ('hardwareConcurrency' in navigator && navigator.hardwareConcurrency) {\n      components.push(`cores:${navigator.hardwareConcurrency}`);\n    }\n    if ('deviceMemory' in navigator && navigator.deviceMemory) {\n      components.push(`mem:${navigator.deviceMemory}`);\n    }\n  }\n\n  // Screen-based components.\n  if (exists(screen)) {\n    components.push(`colorDepth:${screen.colorDepth}`);\n    components.push(`width:${screen.width}`);\n    components.push(`height:${screen.height}`);\n\n    if (screen.availWidth) {\n      components.push(`availWidth:${screen.availWidth}`);\n    }\n    if (screen.availHeight) {\n      components.push(`availHeight:${screen.availHeight}`);\n    }\n  }\n\n  // Timezone offset.\n  components.push(`tz:${new Date().getTimezoneOffset()}`);\n  \n  return components.filter(Boolean).join('||');\n}\n\n/**\n * Detects the current JavaScript execution context in a web environment.\n * This helps differentiate between various browser contexts (main thread,\n * workers, etc.) for more accurate fingerprinting.\n * \n * @returns String identifying the execution context\n */\nfunction detectContext(): string {\n  // Traditional browser (window & document exist)\n  if (exists(window) && exists(document)) {\n    return 'browser';\n  }\n  // Web worker environments (no document, but importScripts is available)\n  if (exists(self) && typeof importScripts === 'function') {\n    // Check for a service worker context\n    if (isInstance(self, ServiceWorkerGlobalScope)) {\n      return 'service-worker';\n    }\n    if (isInstance(self, DedicatedWorkerGlobalScope)) {\n      return 'dedicated-worker';\n    }\n    if (isInstance(self, SharedWorkerGlobalScope)) {\n      return 'shared-worker';\n    }\n    return 'web-worker';\n  }\n  return 'unknown';\n}\n\n/**\n * Type guard to check if an object exists (is not undefined).\n * \n * @param object - The object to check\n * @returns True if the object exists, false otherwise\n */\nfunction exists<T>(object: unknown): object is T {\n  return typeof object !== 'undefined';\n}\n\n/**\n * Type guard to check if an object is an instance of a specified type.\n * \n * @param object - The object to check\n * @param type - The type to check against\n * @returns True if the object is an instance of the specified type\n */\nfunction isInstance<T>(object: unknown, type: T): object is T {\n  return typeof type !== 'undefined' && object instanceof (type as any);\n}\n", "/**\n * @module nexid/common/constants\n * \n * Core constants used throughout the NeXID library.\n * \n * ARCHITECTURE:\n * This module centralizes all constant values used in XID encoding, \n * generation, and manipulation. By isolating these values, we ensure\n * consistent behavior across all components and provide a single source\n * of truth for key parameters of the XID specification.\n */\n\n/**\n * Character set for base32-hex encoding.\n * Uses digits 0-9 and lowercase letters a-v, creating an URL-safe encoding.\n * This alphabet is compatible with the original XID specification.\n */\nexport const ENCODING = '0123456789abcdefghijklmnopqrstuv';\n\n/**\n * Length of the encoded ID string (20 characters).\n * Each 5 bits of the 12-byte binary ID is encoded as one character.\n */\nexport const ENCODED_LEN = 20;\n\n/**\n * Length of the raw binary ID in bytes (12 bytes / 96 bits).\n * This consists of 4 bytes timestamp + 3 bytes machine ID + 2 bytes process ID + 3 bytes counter.\n */\nexport const RAW_LEN = 12;\n\n/** 8-bit (1 byte) mask for byte operations */\nexport const BYTE_MASK = 0xff;\n\n/** 16-bit (2 bytes) mask for process ID */\nexport const PROCESS_ID_MASK = 0xffff;\n", "/**\n * @module nexid/env/lib/process-id/web\n * \n * Process ID generation for web browser environments.\n * \n * ARCHITECTURE:\n * This module provides a simple implementation of process ID generation for\n * web environments. Since browsers don't have a concept of process IDs like\n * server environments do, this implementation generates a random value that\n * remains stable for the lifetime of the page/tab.\n * \n * In browser contexts, the \"process ID\" serves to differentiate between\n * different tabs or windows of the same origin, ensuring that IDs generated\n * in separate browser contexts don't collide even on the same device.\n * \n * PERFORMANCE:\n * This implementation uses Math.random() which is very fast but less random\n * than cryptographic solutions. Since the process ID is only one component\n * of the XID and only needs to differentiate between browser contexts,\n * this approach provides a good balance of performance and uniqueness.\n */\n\nimport { PROCESS_ID_MASK } from 'nexid/common/constants';\nimport { FeatureSet } from 'nexid/env/registry';\n\n/**\n * Generates a random process ID for browser environments.\n * \n * The generated value simulates a process ID in web contexts where \n * no native concept of process exists. The random value is limited\n * to the valid range for the process ID component of an XID.\n * \n * @returns Promise resolving to a random process ID between 0 and PROCESS_ID_MASK\n */\nexport const getProcessId: FeatureSet['ProcessId'] = async (): Promise<number> => {\n  return Math.random() * PROCESS_ID_MASK;\n};\n", "/**\n * @module nexid/env/lib/random-bytes/web-crypto\n * \n * Web Crypto API implementation of secure random bytes generation.\n * \n * ARCHITECTURE:\n * This module provides an implementation of the RandomBytes feature using\n * the Web Crypto API's getRandomValues() method. This is the recommended\n * approach for generating cryptographically secure random values in browser\n * environments and is widely supported across all modern browsers.\n * \n * SECURITY:\n * - Uses the browser's cryptographically secure random number generator\n * - Suitable for cryptographic applications and secure ID generation\n * - Guaranteed to be from a high-quality entropy source\n */\n\nimport { FeatureSet } from 'nexid/env/registry';\n\n/**\n * Generates cryptographically secure random bytes using the Web Crypto API.\n * \n * @param size - Number of random bytes to generate\n * @returns Uint8Array containing the requested number of random bytes\n */\nexport const randomBytes: FeatureSet['RandomBytes'] = (size: number) => {\n  const bytes = new Uint8Array(size);\n  return globalThis.crypto.getRandomValues(bytes);\n};\n", "/**\n * @module nexid/core/encoding\n *\n * NeXID Core - Encoding and Decoding Implementation\n *\n * ARCHITECTURE:\n * This module provides highly optimized encoding and decoding functions for XID values,\n * converting between binary representation and string format. It uses a modified \n * base32-hex encoding that is URL-safe, case-insensitive, and maintains lexicographical \n * sorting properties across all platforms.\n *\n * The encoding process transforms the 12-byte binary ID into a 20-character string,\n * where each character represents 5 bits of data (with the final character using\n * only 4 bits).\n * \n * PERFORMANCE:\n * - Pre-computed lookup tables for both encoding and decoding\n * - Direct byte access and bit manipulation for minimal overhead\n * - Single-operation string construction\n * - Optimized error handling with early validation\n * - Manually unrolled loops for maximum throughput\n */\n\nimport { ENCODED_LEN, ENCODING, RAW_LEN } from 'nexid/common/constants';\nimport { XIDBytes } from 'nexid/types/xid';\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Pre-computed array of character codes for the encoding alphabet.\n * This optimizes encoding by avoiding repeated character code lookups.\n */\nconst ENCODING_CHARS: Uint8Array = new Uint8Array(Array.from(ENCODING).map((c) => c.charCodeAt(0)));\n\n/**\n * Lookup table for decoding base32-hex characters to their 5-bit values.\n *\n * This table maps ASCII character codes to their corresponding 5-bit values\n * in the base32-hex encoding. Invalid characters are marked with 0xff.\n * This pre-computation significantly improves decoding performance by\n * eliminating character lookups during the critical path.\n */\nconst DECODING_TABLE: Uint8Array = (() => {\n  // Create a table covering the ASCII range (0-122)\n  // Pre-fill with invalid character marker (0xff)\n  const table = new Uint8Array(123).fill(0xff);\n\n  // Populate the table with valid character mappings\n  for (let i = 0; i < ENCODING.length; i++) {\n    table[ENCODING.charCodeAt(i)] = i;\n  }\n\n  return table;\n})();\n\n// Reuse a number array for character codes instead of string array\nconst ENCODING_DEST = new Array<number>(ENCODED_LEN);\n\n// ============================================================================\n// Encoding Functions\n// ============================================================================\n\n/**\n * Encodes a 12-byte ID to a 20-character base32-hex string.\n *\n * This is a highly-optimized implementation that:\n * 1. Pre-caches character codes from the encoding alphabet\n * 2. Directly accesses byte values to avoid array lookups\n * 3. Builds the final string in a single operation from character codes\n *\n * @param id - Raw 12-byte ID to encode\n * @returns A 20-character base32-hex encoded string\n */\nexport function encode(id: XIDBytes): string {\n  const charCodes = ENCODING_DEST;\n\n  // Access bytes directly for performance optimization\n  const b0 = id[0],\n    b1 = id[1],\n    b2 = id[2],\n    b3 = id[3],\n    b4 = id[4],\n    b5 = id[5],\n    b6 = id[6],\n    b7 = id[7],\n    b8 = id[8],\n    b9 = id[9],\n    b10 = id[10],\n    b11 = id[11];\n\n  // Reverse order filling to keep bit significance (highest to lowest-order).\n  // Preserves sort order: newer IDs (with a higher timestamp) will compare greater lexicographically\n  charCodes[19] = ENCODING_CHARS[(b11 << 4) & 0x1f];\n  charCodes[18] = ENCODING_CHARS[(b11 >> 1) & 0x1f];\n  charCodes[17] = ENCODING_CHARS[((b11 >> 6) | (b10 << 2)) & 0x1f];\n  charCodes[16] = ENCODING_CHARS[(b10 >> 3) & 0x1f];\n  charCodes[15] = ENCODING_CHARS[b9 & 0x1f];\n  charCodes[14] = ENCODING_CHARS[((b9 >> 5) | (b8 << 3)) & 0x1f];\n  charCodes[13] = ENCODING_CHARS[(b8 >> 2) & 0x1f];\n  charCodes[12] = ENCODING_CHARS[((b8 >> 7) | (b7 << 1)) & 0x1f];\n  charCodes[11] = ENCODING_CHARS[((b7 >> 4) | (b6 << 4)) & 0x1f];\n  charCodes[10] = ENCODING_CHARS[(b6 >> 1) & 0x1f];\n  charCodes[9] = ENCODING_CHARS[((b6 >> 6) | (b5 << 2)) & 0x1f];\n  charCodes[8] = ENCODING_CHARS[(b5 >> 3) & 0x1f];\n  charCodes[7] = ENCODING_CHARS[b4 & 0x1f];\n  charCodes[6] = ENCODING_CHARS[((b4 >> 5) | (b3 << 3)) & 0x1f];\n  charCodes[5] = ENCODING_CHARS[(b3 >> 2) & 0x1f];\n  charCodes[4] = ENCODING_CHARS[((b3 >> 7) | (b2 << 1)) & 0x1f];\n  charCodes[3] = ENCODING_CHARS[((b2 >> 4) | (b1 << 4)) & 0x1f];\n  charCodes[2] = ENCODING_CHARS[(b1 >> 1) & 0x1f];\n  charCodes[1] = ENCODING_CHARS[((b1 >> 6) | (b0 << 2)) & 0x1f];\n  charCodes[0] = ENCODING_CHARS[(b0 >> 3) & 0x1f];\n\n  // Convert character codes to string all at once.\n  // This is more efficient than building the string character by character\n  return String.fromCharCode.apply(null, charCodes);\n}\n\n/**\n * Decodes a 20-character base32-hex string to a 12-byte ID.\n *\n * The decoding process maps each character from the base32-hex alphabet\n * back to its 5-bit value, then reassembles these values into the original\n * 12-byte binary format.\n *\n * @param str - The 20-character string to decode\n * @returns The decoded 12-byte buffer\n * @throws Error if the input string is invalid (wrong length or invalid characters)\n */\nexport function decode(str: string): Uint8Array {\n  // Validate input length\n  if (!str || str.length !== ENCODED_LEN) {\n    throw new Error(`Invalid XID length: expected ${ENCODED_LEN}, got ${str?.length || 0}`);\n  }\n\n  // Prepare output buffer\n  const id = new Uint8Array(RAW_LEN);\n\n  // Fast path with direct character code access (unrolled loop)\n  // Optimize by pre-fetching all character codes at once\n  const charCodes = new Uint8Array(ENCODED_LEN);\n  for (let i = 0; i < ENCODED_LEN; i++) {\n    charCodes[i] = str.charCodeAt(i);\n  }\n\n  // Use a try-catch for efficient bounds checking\n  try {\n    // Get decoded values directly (using a typed array for better performance)\n    const decodedValues = new Uint8Array(ENCODED_LEN);\n    for (let i = 0; i < ENCODED_LEN; i++) {\n      const charCode = charCodes[i];\n      const value = DECODING_TABLE[charCode];\n\n      // Fast check for invalid characters\n      if (value === 0xff) {\n        throw new Error(`Invalid character '${str[i]}' at position ${i}`);\n      }\n\n      decodedValues[i] = value;\n    }\n\n    // Unpack 5-bit values to bytes (manually unrolled for performance)\n    // Group by output byte for better readability\n    id[0] = (decodedValues[0] << 3) | (decodedValues[1] >> 2);\n    id[1] = (decodedValues[1] << 6) | (decodedValues[2] << 1) | (decodedValues[3] >> 4);\n    id[2] = (decodedValues[3] << 4) | (decodedValues[4] >> 1);\n    id[3] = (decodedValues[4] << 7) | (decodedValues[5] << 2) | (decodedValues[6] >> 3);\n    id[4] = (decodedValues[6] << 5) | decodedValues[7];\n    id[5] = (decodedValues[8] << 3) | (decodedValues[9] >> 2);\n    id[6] = (decodedValues[9] << 6) | (decodedValues[10] << 1) | (decodedValues[11] >> 4);\n    id[7] = (decodedValues[11] << 4) | (decodedValues[12] >> 1);\n    id[8] = (decodedValues[12] << 7) | (decodedValues[13] << 2) | (decodedValues[14] >> 3);\n    id[9] = (decodedValues[14] << 5) | decodedValues[15];\n    id[10] = (decodedValues[16] << 3) | (decodedValues[17] >> 2);\n    id[11] = (decodedValues[17] << 6) | (decodedValues[18] << 1) | (decodedValues[19] >> 4);\n\n    // Consistency check (verifies that encoding/decoding round trips properly)\n    if (ENCODING[(id[11] << 4) & 0x1f] !== str[19]) {\n      throw new Error('XID consistency check failed');\n    }\n\n    return id;\n  } catch (e) {\n    if (e instanceof Error && e.message.includes('Invalid character')) {\n      throw e; // Rethrow specific validation errors\n    }\n\n    // Handle out-of-bounds errors with more useful information\n    if (e instanceof Error && e.message.includes('out of range')) {\n      // Find which character caused the issue\n      for (let i = 0; i < ENCODED_LEN; i++) {\n        const charCode = charCodes[i];\n        if (charCode >= DECODING_TABLE.length || DECODING_TABLE[charCode] === 0xff) {\n          throw new Error(`Invalid character '${str[i]}' (code ${charCode}) at position ${i}`);\n        }\n      }\n    }\n\n    // Otherwise, wrap the original error\n    throw new Error(`XID decoding error: ${e instanceof Error ? e.message : String(e)}`);\n  }\n}\n", "/**\n * @module nexid/core/xid\n *\n * Core XID immutable value type and operations.\n *\n * ARCHITECTURE:\n * This module provides the fundamental XID implementation - globally unique,\n * lexicographically sortable identifiers with a rich functional API. Each XID\n * consists of 12 bytes (96 bits) with the following structure:\n *\n *   \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n *   \u25510             3\u25514             6\u25517             8\u25519            11\u2551\n *   \u2551--- 4 bytes ---\u2551--- 3 bytes ---\u2551--- 2 bytes ---\u2551--- 3 bytes ---\u2551\n *   \u2551\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2551\n *   \u2551     time      \u2551   machine ID  \u2551   process ID  \u2551    counter    \u2551\n *   \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n *\n * DESIGN PRINCIPLES:\n * - Immutability: all XID values and operations are immutable\n * - Functional composition: pure operations on value objects\n * - Type safety: comprehensive type definitions with exhaustive checks\n *\n * SECURITY:\n * - Copy-on-read for component extraction to prevent tampering\n * - Strict validation for all inputs\n * - No mutation methods provided on XID instances\n */\n\nimport { ENCODED_LEN, RAW_LEN } from 'nexid/common/constants';\nimport { XIDBytes } from 'nexid/types/xid';\nimport { decode, encode } from './encoding';\n\n/**\n * Immutable XID class representing a globally unique identifier.\n *\n * An XID is a 12-byte value with a specific structure that ensures\n * both uniqueness and lexicographical sortability. XIDs can be\n * serialized to a compact 20-character URL-safe string representation.\n */\nexport class XID {\n  /**\n   * Private constructor to ensure XIDs are only created through factory methods.\n   * This enforces proper validation of all XID instances.\n   *\n   * @param bytes - The underlying byte array for the XID\n   * @private\n   */\n  private constructor(public readonly bytes: XIDBytes) {}\n\n  // ============================================================================\n  // Factory static methods\n  // ============================================================================\n\n  /**\n   * Creates an XID from a raw byte array.\n   *\n   * @param bytes - The 12-byte array to create the ID from\n   * @returns A new XID instance\n   * @throws Error if the input is not a valid 12-byte Uint8Array\n   */\n  public static fromBytes(bytes: Uint8Array): XID {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new Error('ID is not a Uint8Array');\n    }\n    if (bytes.length !== RAW_LEN) {\n      throw new Error('Invalid id length');\n    }\n    return new XID(bytes as XIDBytes);\n  }\n\n  /**\n   * Parses an XID from its 20-character string representation.\n   *\n   * @param str - The string to parse (expected to be 20 characters in base32-hex format)\n   * @returns A new XID instance\n   * @throws Error if the input string is invalid or malformed\n   */\n  public static fromString(str: string): XID {\n    if (str.length !== ENCODED_LEN) {\n      throw new Error('Invalid id length');\n    }\n    if (!/[0-9a-v]{20}/.test(str)) {\n      throw new Error('Invalid string id (must be 20 chars, 0-9 a-v');\n    }\n    return new XID(decode(str) as XIDBytes);\n  }\n\n  /**\n   * Creates a nil (zero) XID, useful as a default value or placeholder.\n   *\n   * @returns A nil XID (all bytes set to zero)\n   */\n  public static nilID(): XID {\n    return new XID(new Uint8Array(RAW_LEN) as XIDBytes);\n  }\n\n  // ============================================================================\n  // Component getters\n  // ============================================================================\n\n  /**\n   * Extracts the timestamp portion of the XID as a JavaScript Date object.\n   *\n   * @returns A Date object representing when the ID was created\n   */\n  get time(): Date {\n    const id = this.bytes;\n    // First 4 bytes contain Unix timestamp (seconds since epoch)\n    const seconds = (id[0] << 24) | (id[1] << 16) | (id[2] << 8) | id[3];\n    return new Date(seconds * 1000);\n  }\n\n  /**\n   * Extracts the machine identifier component from the XID.\n   * This is a 3-byte value derived from platform-specific identifiers.\n   *\n   * @returns A copy of the 3-byte machine ID portion\n   */\n  get machineId(): Uint8Array {\n    return this.bytes.slice(4, 7);\n  }\n\n  /**\n   * Extracts the process ID component from the XID.\n   * This is a 2-byte value of the process that generated the ID.\n   *\n   * @returns A number representing the process ID\n   */\n  get processId(): number {\n    const id = this.bytes;\n    return (id[7] << 8) | id[8];\n  }\n\n  /**\n   * Extracts the counter component from the XID.\n   * This is a 3-byte value that increments for each ID generated by the same\n   * process, ensuring uniqueness even when multiple IDs are generated in the same second.\n   *\n   * @returns A number representing the counter value\n   */\n  get counter(): number {\n    const id = this.bytes;\n    return (id[9] << 16) | (id[10] << 8) | id[11];\n  }\n\n  // ============================================================================\n  // Instance methods\n  // ============================================================================\n\n  /**\n   * Converts the XID to its 20-character base32-hex string representation.\n   * This string is URL-safe, compact, and maintains lexicographical ordering.\n   *\n   * @returns A 20-character string representation of the XID\n   */\n  toString(): string {\n    return encode(this.bytes);\n  }\n\n  /**\n   * Checks if this XID is a nil (zero) ID.\n   * A nil ID has all bytes set to zero and is typically used as a placeholder or default value.\n   *\n   * @returns True if this is a nil ID, false otherwise\n   */\n  isNil(): boolean {\n    return this.bytes.every((byte) => byte === 0);\n  }\n\n  /**\n   * Checks if this XID is equal to another XID.\n   * Two XIDs are equal if they contain the same bytes in the same order.\n   *\n   * @param other - Second XID to compare\n   * @returns True if the XIDs contain identical bytes, false otherwise\n   */\n  equals(other: XID): boolean {\n    if (this === other) return true;\n    return this.bytes.every((byte, i) => byte === other.bytes[i]);\n  }\n}\n", "/**\n * @module nexid/core/counter\n * \n * Atomic counter implementation for thread-safe ID generation.\n * \n * ARCHITECTURE:\n * This module provides a cross-environment atomic counter with several\n * key features:\n * 1. Support for SharedArrayBuffer in modern environments\n * 2. Fallback to WebAssembly shared memory where available\n * 3. Last resort fallback to regular ArrayBuffer for basic environments\n * \n * PERFORMANCE:\n * - Uses native atomic operations for thread safety without locks\n * - Minimal memory overhead with typed arrays\n * - Counter overflow management to prevent duplicate values\n */\n\nimport { CounterValue } from 'nexid/types/xid';\n\n/**\n * Thread-safe counter interface for generating unique, monotonically\n * increasing values.\n */\nexport interface AtomicCounter {\n  /**\n   * Gets the next unique counter value.\n   * \n   * @returns A unique counter value (24-bit integer)\n   */\n  getNext(): CounterValue;\n}\n\n/**\n * Creates an atomic counter with the specified initial seed value.\n * \n * The implementation automatically selects the most appropriate\n * shared memory mechanism for the current runtime environment.\n * \n * @param seed - Initial value for the counter\n * @returns A thread-safe atomic counter\n */\nexport function createAtomicCounter(seed: number): AtomicCounter {\n  let buffer: ArrayBuffer;\n\n  if (globalThis.SharedArrayBuffer) {\n    buffer = new SharedArrayBuffer(4);\n  } else if (globalThis.WebAssembly) {\n    buffer = new WebAssembly.Memory({ initial: 1, maximum: 1, shared: true }).buffer;\n    //                                         \u255A\u2550 1 page = 64KiB\n  } else {\n    buffer = new ArrayBuffer(4);\n  }\n\n  const counter = new Uint32Array(buffer);\n  counter[0] = seed;\n\n  return {\n    getNext(): CounterValue {\n      const value = Atomics.add(counter, 0, 1);\n\n      // Handle overflow\n      if (value === 0) {\n        counter[0] = seed & 0xffff;\n      }\n\n      return (value & 0xffffff) as CounterValue;\n    },\n  };\n}\n", "/**\n * @module nexid/core/xid-generator\n *\n * XID Generator - Core Implementation\n *\n * ARCHITECTURE:\n * This module implements the central ID generation algorithm for NeXID,\n * following the XID specification with custom enhancements for performance\n * and cross-environment compatibility. The generator manages the creation\n * of unique identifiers by combining:\n *\n * 1. Timestamp (4 bytes) - Current time in seconds\n * 2. Machine ID (3 bytes) - Environment-specific identifier\n * 3. Process ID (2 bytes) - Current process or context identifier\n * 4. Counter (3 bytes) - Thread-safe incrementing counter\n *\n * SECURITY:\n * - Uses cryptographically secure random sources when available\n * - Machine IDs are cryptographically hashed to prevent system information disclosure\n * - Random counter initialization to prevent predictable sequences\n *\n * PERFORMANCE:\n * - Pre-allocation of buffer template for minimal GC pressure\n * - Optimized byte manipulation for maximum throughput\n * - Provides fast path for string-only ID generation\n */\n\nimport { BYTE_MASK, RAW_LEN } from 'nexid/common/constants';\nimport { Environment } from 'nexid/env/registry';\nimport { XIDBytes } from 'nexid/types/xid';\nimport { Generator } from 'nexid/types/xid-generator';\nimport { createAtomicCounter } from './counter';\nimport { encode } from './encoding';\nimport { XID } from './xid';\n\n/**\n * Creates an XID generator with the specified environment and options.\n *\n * The generator ensures uniqueness through a combination of timestamp,\n * machine ID, process ID, and atomic counter components.\n *\n * @param env - Environment abstraction providing platform capabilities\n * @param options - Optional configuration parameters\n * @returns Promise resolving to generator API\n */\nexport async function XIDGenerator(\n  env: Environment,\n  options: Generator.Options = {}\n): Promise<Generator.API> {\n  // ==========================================================================\n  // Setup components\n  // ==========================================================================\n  // Resolve capabilities\n  const randomBytes = await env.get('RandomBytes', options.randomBytes || null);\n  const hashFunction = await env.get('HashFunction');\n  const getMachineId = await env.get(\n    'MachineId',\n    options.machineId ? async () => options.machineId as string : null\n  );\n\n  // Use first 3 bytes of machineId hash\n  const machineId = await getMachineId();\n  const machineIdBytes = (await hashFunction(machineId)).subarray(0, 3);\n\n  // Process ID\n  let getProcessId = await env.get(\n    'ProcessId',\n    options.processId ? async () => options.processId as number : null\n  );\n  const processId = (await getProcessId()) & 0xffff;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n  /**\n   * Preset constant bytes (machine id & process id) into a base buffer\n   * that will be reused for each XID generation.\n   */\n  const baseBuffer = new Uint8Array(RAW_LEN);\n\n  // Machine ID (3 bytes)\n  baseBuffer[4] = machineIdBytes[0] & BYTE_MASK;\n  baseBuffer[5] = machineIdBytes[1] & BYTE_MASK;\n  baseBuffer[6] = machineIdBytes[2] & BYTE_MASK;\n\n  // Process ID (2 bytes, big endian)\n  baseBuffer[7] = (processId >> 8) & BYTE_MASK;\n  baseBuffer[8] = processId & BYTE_MASK;\n\n  /** Setup atomic counter **/\n  const b1 = randomBytes(3);\n  const b2 = randomBytes(3);\n  const b3 = randomBytes(3);\n  const randomSeed = (b1[0] << 16) | (b2[1] << 8) | b3[2];\n  const counter = createAtomicCounter(randomSeed);\n\n  // ==========================================================================\n  // XID generation\n  // ==========================================================================\n  /**\n   * Builds a new XID byte array with the specified timestamp.\n   *\n   * @param timestamp - Timestamp in milliseconds since epoch\n   * @returns Immutable XID byte array\n   */\n  function buildXIDBytes(timestamp: number): Readonly<XIDBytes> {\n    const buffer = new Uint8Array(baseBuffer);\n\n    // Convert to seconds for the ID (XID spec uses seconds, not milliseconds)\n    timestamp = Math.floor(timestamp / 1000);\n\n    // Timestamp (4 bytes, big endian)\n    buffer[0] = (timestamp >> 24) & BYTE_MASK;\n    buffer[1] = (timestamp >> 16) & BYTE_MASK;\n    buffer[2] = (timestamp >> 8) & BYTE_MASK;\n    buffer[3] = timestamp & BYTE_MASK;\n\n    // Counter (3 bytes, big endian)\n    const currentCounter = counter.getNext();\n    buffer[9] = (currentCounter >> 16) & BYTE_MASK;\n    buffer[10] = (currentCounter >> 8) & BYTE_MASK;\n    buffer[11] = currentCounter & BYTE_MASK;\n\n    return buffer as XIDBytes;\n  }\n\n  // ==========================================================================\n  // Export API\n  // ==========================================================================\n  return {\n    machineId,\n    processId,\n    /**\n     * Generates a new XID with the specified timestamp (defaults to current time).\n     *\n     * @param datetime - Optional date to use instead of current time\n     * @returns A new XID object\n     */\n    newId(datetime?: Date) {\n      const timestamp = datetime instanceof Date ? +datetime : Date.now();\n      return XID.fromBytes(buildXIDBytes(timestamp));\n    },\n\n    /**\n     * Generates a new XID string directly, bypassing object creation.\n     * This is approximately 30% faster than newId() when only the string\n     * representation is needed.\n     *\n     * @returns A string representation of a new XID\n     */\n    fastId() {\n      return encode(buildXIDBytes(Date.now()));\n    },\n  };\n}\n", "/**\n * @module nexid/env/lib/hash-function\n * \n * Cryptographic hash function feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the HashFunction feature,\n * which provides a secure way to hash identifiers before using them in XIDs.\n * Hashing machine IDs and other inputs helps protect sensitive information\n * while still maintaining uniqueness.\n * \n * The hash function should ideally be cryptographically secure whenever possible:\n * - Node.js uses the crypto module's SHA-256 implementation\n * - Browsers use the SubtleCrypto API's SHA-256 implementation\n * - Fallback uses a simple but sufficient non-cryptographic hash function\n * \n * SECURITY:\n * - All platform-specific implementations should use SHA-256 when available\n * - The fallback implementation (FNV-1a) is only used when secure APIs aren't available\n * - Appropriate warnings are displayed when falling back to less secure alternatives\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the HashFunction feature including validation and fallback.\n */\nexport const HashFunctionDefinition: FeatureDefinition<'HashFunction'> = {\n  /**\n   * Tests if the provided implementation is a valid HashFunction function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = await impl('custom-hash-test');\n      return result instanceof Uint8Array && result.length === 32;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Simple fallback hash function when cryptographic APIs are unavailable.\n   * Uses FNV-1a (Fowler\u2013Noll\u2013Vo) hash algorithm which is fast and has\n   * good distribution properties. While not cryptographically secure,\n   * it's sufficient for generating machine IDs.\n   *\n   * SECURITY NOTE: This hash function is NOT cryptographically secure\n   * and should only be used when no secure alternatives are available.\n   *\n   * @param data - String or byte array to hash\n   * @returns A 32-byte hash as a Uint8Array\n   */\n  async fallback(data: string | Uint8Array): Promise<Uint8Array> {\n    console.warn('Using non-secure fallback (hash)');\n\n    // Convert input to string\n    const str = typeof data === 'string' ? data : data.toString();\n\n    // FNV prime: 16777619 (0x01000193)\n    // FNV offset basis: 2166136261 (0x811c9dc5)\n    let h = 0x811c9dc5;\n    for (let i = 0; i < str.length; i++) {\n      h ^= str.charCodeAt(i);\n      h = (h * 0x01000193) >>> 0; // multiply by FNV prime and ensure 32-bit unsigned\n    }\n\n    // Create a result buffer filled with variations of the hash\n    const byteArray = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      byteArray[i] = ((h ^ (i * 0x53)) + i) & 0xff;\n    }\n\n    return byteArray;\n  },\n};\n", "/**\n * @module nexid/env/lib/machine-id\n * \n * Machine ID feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the MachineId feature,\n * which is responsible for generating a consistent identifier for the current\n * machine/device. This component is critical for ensuring ID uniqueness across\n * different devices in a distributed system.\n * \n * Different platforms expose machine identification in different ways:\n * - Server environments may use MAC addresses, hostname, or OS-specific identifiers\n * - Browsers use fingerprinting techniques while respecting privacy\n * - Mobile devices have their own device identifiers\n * \n * SECURITY:\n * - Machine IDs should be stable but not expose sensitive system information\n * - The machine ID is cryptographically hashed before use in XIDs\n * - Fallback implementation provides uniqueness but with appropriate warnings\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the MachineId feature including validation and fallback.\n */\nexport const MachineIdDefinition: FeatureDefinition<'MachineId'> = {\n  /**\n   * Tests if the provided implementation is a valid MachineId function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = await impl();\n      return !!result && typeof result === 'string' && result.length > 0;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Generates a random machine ID when no hardware identifiers are available.\n   * This fallback uses a combination of timestamp and random values to create\n   * a reasonably unique identifier that won't collide with other instances.\n   *\n   * SECURITY NOTE: This implementation is NOT cryptographically secure\n   * and should not be used for any security-critical purposes.\n   *\n   * @returns A Promise that resolves to a machine identifier string\n   */\n  async fallback(): Promise<string> {\n    console.warn('Using non-secure fallback (machine id)');\n    const timestamp = Date.now().toString(36);\n    const random = () => Math.random().toString(36).substring(2, 10);\n    return `${random()}-${timestamp}-${random()}`;\n  },\n};\n", "/**\n * @module nexid/env/lib/process-id\n * \n * Process ID feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the ProcessId feature,\n * which provides a stable identifier for the current process or execution context.\n * This component helps ensure uniqueness of XIDs generated within the same machine\n * but by different processes or contexts.\n * \n * Different runtimes have different concepts of \"process\":\n * - Node.js has actual process IDs from the operating system\n * - Browsers use tab/window IDs or random values that are stable during a session\n * - Workers and service workers track their context IDs\n * \n * The process ID is a 2-byte value in the XID, allowing for up to 65,535 unique\n * processes or contexts on a single machine without risk of collisions.\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the ProcessId feature including validation and fallback.\n */\nexport const ProcessIdDefinition: FeatureDefinition<'ProcessId'> = {\n  /**\n   * Tests if the provided implementation is a valid ProcessId function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = await impl();\n      return typeof result === 'number' && result > 0;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Generates a random process ID when process information is unavailable.\n   * This ensures IDs can still be generated with some level of uniqueness.\n   *\n   * @returns A Promise that resolves to a randomly generated process ID\n   */\n  async fallback(): Promise<number> {\n    console.warn('Using non-secure fallback (process id)');\n    // Generate a random number between 1 and 65535 (0xFFFF)\n    return Math.floor(Math.random() * 0xffff) + 1;\n  },\n};\n", "/**\n * @module nexid/env/lib/random-bytes\n * \n * Random bytes feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the RandomBytes feature,\n * which is responsible for generating cryptographically secure random values.\n * The feature is critical for the security of generated IDs, as it provides\n * the unpredictable component that prevents ID collisions and guessing.\n * \n * SECURITY:\n * - Defines test function to validate that implementations produce proper output\n * - Provides a non-secure fallback using Math.random() with appropriate warnings\n * - Platform-specific implementations should use the best available source of entropy\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the RandomBytes feature including validation and fallback.\n */\nexport const RandomBytesDefinition: FeatureDefinition<'RandomBytes'> = {\n  /**\n   * Tests if the provided implementation is a valid RandomBytes function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = impl(5);\n      return result instanceof Uint8Array && result.length === 5;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Fallback random source that uses Math.random().\n   * WARNING: This is NOT cryptographically secure and should only be used\n   * when no secure alternatives are available.\n   *\n   * @param size - Number of random bytes to generate\n   * @returns Uint8Array of pseudo-random values\n   */\n  fallback(size: number): Uint8Array {\n    console.warn('Using non-secure fallback (randomBytes)');\n\n    const byteArray = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n      byteArray[i] = Math.floor(Math.random() * 256);\n    }\n    return byteArray;\n  },\n};\n", "/**\n * @module nexid/env/registry\n *\n * Environment features registry and resolution system.\n *\n * ARCHITECTURE:\n * This module implements a capability-based environment abstraction layer\n * that enables the library to adapt to different JavaScript runtimes while\n * providing a consistent API. The registry:\n *\n * 1. Defines the core capabilities required by the ID generator\n * 2. Manages the validation and fallback mechanisms for these capabilities\n * 3. Implements a resolution system with caching for performance\n *\n * This abstraction allows the core library code to remain platform-agnostic\n * while still utilizing environment-specific optimizations when available.\n */\n\nimport { HashFunctionDefinition } from './lib/hash-function/@definition';\nimport { MachineIdDefinition } from './lib/machine-id/@definition';\nimport { ProcessIdDefinition } from './lib/process-id/@definition';\nimport { RandomBytesDefinition } from './lib/random-bytes/@definition';\n\n// ============================================================================\n// Types\n// ============================================================================\n/**\n * Core capabilities required by the XID generator.\n * Each capability is implemented differently based on the runtime environment.\n */\nexport type FeatureSet = {\n  /** Generates cryptographically secure random bytes */\n  RandomBytes: (size: number) => Uint8Array;\n\n  /** Creates a cryptographic hash of input data */\n  HashFunction: (data: string | Uint8Array) => Promise<Uint8Array>;\n\n  /** Provides a stable machine/device identifier */\n  MachineId: () => Promise<string>;\n\n  /** Provides a process-specific identifier */\n  ProcessId: () => Promise<number>;\n};\n\nexport type Feature = keyof FeatureSet;\nexport type FeatureValidator = (impl: unknown) => Promise<boolean>;\n\n/**\n * Definition of a feature including its validation function and fallback implementation.\n */\nexport type FeatureDefinition<F extends Feature> = {\n  test: FeatureValidator;\n  fallback: FeatureSet[F];\n};\n\n/**\n * Platform-specific adapter providing implementations for all required features.\n */\nexport type EnvironmentAdapter = {\n  [F in keyof FeatureSet]: FeatureSet[F];\n};\n\ntype Registry = {\n  [F in keyof FeatureSet]: FeatureDefinition<F>;\n};\n\n// ============================================================================\n// Registry\n// ============================================================================\n/**\n * Global registry of all feature definitions.\n */\nexport const REGISTRY: Registry = {\n  RandomBytes: RandomBytesDefinition,\n  HashFunction: HashFunctionDefinition,\n  MachineId: MachineIdDefinition,\n  ProcessId: ProcessIdDefinition,\n};\n\n/**\n * Environment class that manages feature resolution and caching.\n */\nexport class Environment {\n  private cache: Map<Feature, FeatureSet[Feature]> = new Map();\n\n  constructor(private adapter: EnvironmentAdapter) {}\n\n  /**\n   * Resolves a specific feature implementation, prioritizing:\n   * 1. A provided candidate implementation (if valid)\n   * 2. Previously cached implementation\n   * 3. Adapter-provided implementation\n   * 4. Fallback implementation as a last resort\n   *\n   * @param feature - The capability to resolve\n   * @param candidate - Optional custom implementation to use if valid\n   * @returns Promise resolving to the best available implementation\n   */\n  async get<F extends Feature>(\n    feature: F,\n    candidate?: FeatureSet[F] | null\n  ): Promise<FeatureSet[F]> {\n    const featureDefinition = REGISTRY[feature];\n\n    if (candidate && (await featureDefinition.test(candidate))) {\n      console.log(`NeXID: using user's provided ${feature}: ${candidate}`);\n      this.cache.set(feature, candidate);\n      return candidate;\n    }\n\n    if (this.cache.has(feature)) {\n      return this.cache.get(feature) as FeatureSet[F];\n    }\n\n    const adapterFeature = this.adapter[feature];\n    if (await featureDefinition.test(adapterFeature)) {\n      console.log(`NeXID: using adapter's implementation of ${feature}`);\n      this.cache.set(feature, adapterFeature);\n      return adapterFeature;\n    }\n\n    // Fallback\n    console.log(`NeXID: using fallback ${feature}`);\n    return featureDefinition.fallback;\n  }\n}\n"],
  "mappings": "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",
  "names": ["web_exports", "__export", "XID", "web_default", "init", "hash", "data", "buffer", "getFingerprint", "components", "salt", "timestamp", "detectContext", "exists", "isInstance", "object", "type", "ENCODING", "getProcessId", "randomBytes", "size", "bytes", "ENCODING_CHARS", "ENCODING", "c", "DECODING_TABLE", "table", "i", "ENCODING_DEST", "encode", "id", "charCodes", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "b10", "b11", "decode", "str", "decodedValues", "charCode", "value", "e", "XID", "_XID", "bytes", "str", "decode", "id", "seconds", "encode", "byte", "other", "i", "createAtomicCounter", "seed", "buffer", "counter", "value", "XIDGenerator", "env", "options", "randomBytes", "hashFunction", "machineId", "machineIdBytes", "processId", "baseBuffer", "b1", "b2", "b3", "randomSeed", "counter", "createAtomicCounter", "buildXIDBytes", "timestamp", "buffer", "currentCounter", "datetime", "XID", "encode", "HashFunctionDefinition", "impl", "result", "data", "str", "h", "i", "byteArray", "MachineIdDefinition", "impl", "result", "timestamp", "random", "ProcessIdDefinition", "impl", "result", "RandomBytesDefinition", "impl", "result", "size", "byteArray", "i", "REGISTRY", "RandomBytesDefinition", "HashFunctionDefinition", "MachineIdDefinition", "ProcessIdDefinition", "Environment", "adapter", "feature", "candidate", "featureDefinition", "adapterFeature", "WebAdapter", "Environment", "randomBytes", "hash", "getFingerprint", "getProcessId", "createXIDGenerator", "options", "XIDGenerator", "init", "createXIDGenerator", "web_default"]
}
