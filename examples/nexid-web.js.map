{
  "version": 3,
  "sources": ["../src/web.ts", "../src/env/lib/hash-function/subtle-crypto.ts", "../src/env/lib/machine-id/web-fingerprint.ts", "../src/common/constants.ts", "../src/env/lib/process-id/web.ts", "../src/env/lib/random-bytes/web-crypto.ts", "../src/core/encoding.ts", "../src/core/xid.ts", "../src/core/counter.ts", "../src/core/xid-generator.ts", "../src/env/lib/hash-function/@definition.ts", "../src/env/lib/machine-id/@definition.ts", "../src/env/lib/process-id/@definition.ts", "../src/env/lib/random-bytes/@definition.ts", "../src/env/registry.ts"],
  "sourcesContent": ["/**\n * @module nexid/index-web\n *\n * NeXID Web browser-specific entry point.\n *\n * ARCHITECTURE:\n * This module provides a browser-optimized entry point for the NeXID library,\n * pre-configured with the WebAdapter for client environments. This allows\n * for more efficient bundling in browser applications by avoiding the dynamic\n * environment detection process and eliminating Node.js-specific code.\n *\n * When imported directly, this module uses the WebAdapter without having\n * to detect the environment, providing a small performance benefit during\n * initialization and allowing for more aggressive tree-shaking of server-specific\n * code in bundlers.\n */\n\nimport { hash as subtleCryptoHash } from 'nexid/env/lib/hash-function/subtle-crypto';\nimport { getFingerprint } from 'nexid/env/lib/machine-id/web-fingerprint';\nimport { getProcessId } from 'nexid/env/lib/process-id/web';\nimport { randomBytes as webCryptoRandomBytes } from 'nexid/env/lib/random-bytes/web-crypto';\nimport { XID } from './core/xid';\nimport { XIDGenerator } from './core/xid-generator';\nimport { Environment, EnvironmentAdapter } from './env/registry';\nimport { initNeXID } from './types/api';\nimport { Generator } from './types/xid-generator';\n\nconst WebAdapter = new Environment({\n  RandomBytes: webCryptoRandomBytes,\n  HashFunction: subtleCryptoHash,\n  MachineId: getFingerprint,\n  ProcessId: getProcessId,\n} as EnvironmentAdapter);\n\n/**\n * Creates an XID generator with browser-specific optimizations.\n *\n * @param options - Optional configuration parameters\n * @returns Promise resolving to a fully configured XID generator\n */\nasync function createXIDGenerator(options?: Generator.Options): Promise<Generator.API> {\n  console.log('NeXID: initializing with Web adapter');\n  return XIDGenerator(WebAdapter, options);\n}\n\nexport { XID };\nexport type XIDGenerator = Generator.API;\nexport const init: initNeXID = createXIDGenerator;\nexport default { init: createXIDGenerator };\n", "/**\n * @module nexid/env/lib/hash-function/subtle-crypto\n * \n * Web Crypto API implementation of SHA-256 hashing.\n * \n * ARCHITECTURE:\n * This module provides an implementation of the HashFunction feature using\n * the Web Crypto API's SubtleCrypto interface. It creates a SHA-256 hash of\n * the input data, which is used to transform machine IDs and other identifiers\n * into a format that doesn't expose sensitive information.\n * \n * SECURITY:\n * - Uses the browser's native cryptographic implementation\n * - Provides a cryptographically secure hash for data protection\n * - Handles both string and binary input formats using TextEncoder\n */\n\nimport { FeatureSet } from 'nexid/env/registry';\n\n/**\n * Creates a SHA-256 hash of the input data using the Web Crypto API.\n * Automatically converts string input to UTF-8 byte array before hashing.\n * \n * @param data - String or byte array to hash\n * @returns Promise resolving to a 32-byte Uint8Array containing the hash\n */\nexport const hash: FeatureSet['HashFunction'] = async (data: string | Uint8Array) => {\n  if (typeof data === 'string') {\n    const encoder = new TextEncoder();\n    data = encoder.encode(data);\n  }\n  const buffer = await globalThis.crypto.subtle.digest('SHA-256', data);\n  return new Uint8Array(buffer);\n};\n", "/**\n * @module nexid/env/lib/machine-id/web-fingerprint\n * \n * Browser fingerprinting implementation for machine ID generation.\n * \n * ARCHITECTURE:\n * This module provides a privacy-respecting browser fingerprinting solution\n * for generating stable machine IDs in web environments. It collects various\n * browser characteristics that together can uniquely identify a device while\n * avoiding collection of personally identifiable information.\n * \n * The approach produces a reasonably consistent identifier across browser\n * sessions, which is then cryptographically hashed before use in XIDs.\n * \n * PRIVACY:\n * - No persistent storage is used (no cookies, localStorage, etc.)\n * - No canvas fingerprinting or other invasive techniques\n * - Does not collect personally identifiable information\n * - Only uses available browser APIs that don't require special permissions\n */\n\n/**\n * Generates a pseudo-fingerprint that includes an environment discriminator.\n * This produces a string containing various browser/device characteristics\n * that collectively provide a reasonably stable device identifier.\n * \n * @returns Promise resolving to a string containing fingerprint components\n */\nexport async function getFingerprint(): Promise<string> {\n  const components: string[] = [];\n\n  // Pseudo random salt\n  const salt = ((Math.random() * 0xffff) | 0).toString(16).padStart(2, '0');\n  const timestamp = Date.now().toString(36);\n  components.push(`salt: ${salt}:${timestamp}`);\n\n  // Environment discriminator\n  components.push(`env:${detectContext()}`);\n\n  // Navigator-based components.\n  if (exists(navigator)) {\n    components.push(`ua:${navigator.userAgent || ''}`);\n    components.push(`lang:${navigator.language || ''}`);\n\n    if (navigator.languages && Array.isArray(navigator.languages)) {\n      components.push(`langs:${navigator.languages.join(',')}`);\n    }\n\n    if ('hardwareConcurrency' in navigator && navigator.hardwareConcurrency) {\n      components.push(`cores:${navigator.hardwareConcurrency}`);\n    }\n    if ('deviceMemory' in navigator && navigator.deviceMemory) {\n      components.push(`mem:${navigator.deviceMemory}`);\n    }\n  }\n\n  // Screen-based components.\n  if (exists(screen)) {\n    components.push(`colorDepth:${screen.colorDepth}`);\n    components.push(`width:${screen.width}`);\n    components.push(`height:${screen.height}`);\n\n    if (screen.availWidth) {\n      components.push(`availWidth:${screen.availWidth}`);\n    }\n    if (screen.availHeight) {\n      components.push(`availHeight:${screen.availHeight}`);\n    }\n  }\n\n  // Timezone offset.\n  components.push(`tz:${new Date().getTimezoneOffset()}`);\n  \n  return components.filter(Boolean).join('||');\n}\n\n/**\n * Detects the current JavaScript execution context in a web environment.\n * This helps differentiate between various browser contexts (main thread,\n * workers, etc.) for more accurate fingerprinting.\n * \n * @returns String identifying the execution context\n */\nfunction detectContext(): string {\n  // Traditional browser (window & document exist)\n  if (exists(window) && exists(document)) {\n    return 'browser';\n  }\n  // Web worker environments (no document, but importScripts is available)\n  if (exists(self) && typeof importScripts === 'function') {\n    // Check for a service worker context\n    if (isInstance(self, ServiceWorkerGlobalScope)) {\n      return 'service-worker';\n    }\n    if (isInstance(self, DedicatedWorkerGlobalScope)) {\n      return 'dedicated-worker';\n    }\n    if (isInstance(self, SharedWorkerGlobalScope)) {\n      return 'shared-worker';\n    }\n    return 'web-worker';\n  }\n  return 'unknown';\n}\n\n/**\n * Type guard to check if an object exists (is not undefined).\n * \n * @param object - The object to check\n * @returns True if the object exists, false otherwise\n */\nfunction exists<T>(object: unknown): object is T {\n  return typeof object !== 'undefined';\n}\n\n/**\n * Type guard to check if an object is an instance of a specified type.\n * \n * @param object - The object to check\n * @param type - The type to check against\n * @returns True if the object is an instance of the specified type\n */\nfunction isInstance<T>(object: unknown, type: T): object is T {\n  return typeof type !== 'undefined' && object instanceof (type as any);\n}\n", "/**\n * @module nexid/common/constants\n * \n * Core constants used throughout the NeXID library.\n * \n * ARCHITECTURE:\n * This module centralizes all constant values used in XID encoding, \n * generation, and manipulation. By isolating these values, we ensure\n * consistent behavior across all components and provide a single source\n * of truth for key parameters of the XID specification.\n */\n\n/**\n * Character set for base32-hex encoding.\n * Uses digits 0-9 and lowercase letters a-v, creating an URL-safe encoding.\n * This alphabet is compatible with the original XID specification.\n */\nexport const ENCODING = '0123456789abcdefghijklmnopqrstuv';\n\n/**\n * Length of the encoded ID string (20 characters).\n * Each 5 bits of the 12-byte binary ID is encoded as one character.\n */\nexport const ENCODED_LEN = 20;\n\n/**\n * Length of the raw binary ID in bytes (12 bytes / 96 bits).\n * This consists of 4 bytes timestamp + 3 bytes machine ID + 2 bytes process ID + 3 bytes counter.\n */\nexport const RAW_LEN = 12;\n\n/** 8-bit (1 byte) mask for byte operations */\nexport const BYTE_MASK = 0xff;\n\n/** 16-bit (2 bytes) mask for process ID */\nexport const PROCESS_ID_MASK = 0xffff;\n", "/**\n * @module nexid/env/lib/process-id/web\n * \n * Process ID generation for web browser environments.\n * \n * ARCHITECTURE:\n * This module provides a simple implementation of process ID generation for\n * web environments. Since browsers don't have a concept of process IDs like\n * server environments do, this implementation generates a random value that\n * remains stable for the lifetime of the page/tab.\n * \n * In browser contexts, the \"process ID\" serves to differentiate between\n * different tabs or windows of the same origin, ensuring that IDs generated\n * in separate browser contexts don't collide even on the same device.\n * \n * PERFORMANCE:\n * This implementation uses Math.random() which is very fast but less random\n * than cryptographic solutions. Since the process ID is only one component\n * of the XID and only needs to differentiate between browser contexts,\n * this approach provides a good balance of performance and uniqueness.\n */\n\nimport { PROCESS_ID_MASK } from 'nexid/common/constants';\nimport { FeatureSet } from 'nexid/env/registry';\n\n/**\n * Generates a random process ID for browser environments.\n * \n * The generated value simulates a process ID in web contexts where \n * no native concept of process exists. The random value is limited\n * to the valid range for the process ID component of an XID.\n * \n * @returns Promise resolving to a random process ID between 0 and PROCESS_ID_MASK\n */\nexport const getProcessId: FeatureSet['ProcessId'] = async (): Promise<number> => {\n  return Math.random() * PROCESS_ID_MASK;\n};\n", "/**\n * @module nexid/env/lib/random-bytes/web-crypto\n * \n * Web Crypto API implementation of secure random bytes generation.\n * \n * ARCHITECTURE:\n * This module provides an implementation of the RandomBytes feature using\n * the Web Crypto API's getRandomValues() method. This is the recommended\n * approach for generating cryptographically secure random values in browser\n * environments and is widely supported across all modern browsers.\n * \n * SECURITY:\n * - Uses the browser's cryptographically secure random number generator\n * - Suitable for cryptographic applications and secure ID generation\n * - Guaranteed to be from a high-quality entropy source\n */\n\nimport { FeatureSet } from 'nexid/env/registry';\n\n/**\n * Generates cryptographically secure random bytes using the Web Crypto API.\n * \n * @param size - Number of random bytes to generate\n * @returns Uint8Array containing the requested number of random bytes\n */\nexport const randomBytes: FeatureSet['RandomBytes'] = (size: number) => {\n  const bytes = new Uint8Array(size);\n  return globalThis.crypto.getRandomValues(bytes);\n};\n", "/**\n * @module nexid/core/encoding\n *\n * NeXID Core - Encoding and Decoding Implementation\n *\n * ARCHITECTURE:\n * This module provides highly optimized encoding and decoding functions for XID values,\n * converting between binary representation and string format. It uses a modified \n * base32-hex encoding that is URL-safe, case-insensitive, and maintains lexicographical \n * sorting properties across all platforms.\n *\n * The encoding process transforms the 12-byte binary ID into a 20-character string,\n * where each character represents 5 bits of data (with the final character using\n * only 4 bits).\n * \n * PERFORMANCE:\n * - Pre-computed lookup tables for both encoding and decoding\n * - Direct byte access and bit manipulation for minimal overhead\n * - Single-operation string construction\n * - Optimized error handling with early validation\n * - Manually unrolled loops for maximum throughput\n */\n\nimport { ENCODED_LEN, ENCODING, RAW_LEN } from 'nexid/common/constants';\nimport { XIDBytes } from 'nexid/types/xid';\n\n// ============================================================================\n// Constants\n// ============================================================================\n\n/**\n * Pre-computed array of character codes for the encoding alphabet.\n * This optimizes encoding by avoiding repeated character code lookups.\n */\nconst ENCODING_CHARS: Uint8Array = new Uint8Array(Array.from(ENCODING).map((c) => c.charCodeAt(0)));\n\n/**\n * Lookup table for decoding base32-hex characters to their 5-bit values.\n *\n * This table maps ASCII character codes to their corresponding 5-bit values\n * in the base32-hex encoding. Invalid characters are marked with 0xff.\n * This pre-computation significantly improves decoding performance by\n * eliminating character lookups during the critical path.\n */\nconst DECODING_TABLE: Uint8Array = (() => {\n  // Create a table covering the ASCII range (0-122)\n  // Pre-fill with invalid character marker (0xff)\n  const table = new Uint8Array(123).fill(0xff);\n\n  // Populate the table with valid character mappings\n  for (let i = 0; i < ENCODING.length; i++) {\n    table[ENCODING.charCodeAt(i)] = i;\n  }\n\n  return table;\n})();\n\n// Reuse a number array for character codes instead of string array\nconst ENCODING_DEST = new Array<number>(ENCODED_LEN);\n\n// ============================================================================\n// Encoding Functions\n// ============================================================================\n\n/**\n * Encodes a 12-byte ID to a 20-character base32-hex string.\n *\n * This is a highly-optimized implementation that:\n * 1. Pre-caches character codes from the encoding alphabet\n * 2. Directly accesses byte values to avoid array lookups\n * 3. Builds the final string in a single operation from character codes\n *\n * @param id - Raw 12-byte ID to encode\n * @returns A 20-character base32-hex encoded string\n */\nexport function encode(id: XIDBytes): string {\n  const charCodes = ENCODING_DEST;\n\n  // Access bytes directly for performance optimization\n  const b0 = id[0],\n    b1 = id[1],\n    b2 = id[2],\n    b3 = id[3],\n    b4 = id[4],\n    b5 = id[5],\n    b6 = id[6],\n    b7 = id[7],\n    b8 = id[8],\n    b9 = id[9],\n    b10 = id[10],\n    b11 = id[11];\n\n  // Reverse order filling to keep bit significance (highest to lowest-order).\n  // Preserves sort order: newer IDs (with a higher timestamp) will compare greater lexicographically\n  charCodes[19] = ENCODING_CHARS[(b11 << 4) & 0x1f];\n  charCodes[18] = ENCODING_CHARS[(b11 >> 1) & 0x1f];\n  charCodes[17] = ENCODING_CHARS[((b11 >> 6) | (b10 << 2)) & 0x1f];\n  charCodes[16] = ENCODING_CHARS[(b10 >> 3) & 0x1f];\n  charCodes[15] = ENCODING_CHARS[b9 & 0x1f];\n  charCodes[14] = ENCODING_CHARS[((b9 >> 5) | (b8 << 3)) & 0x1f];\n  charCodes[13] = ENCODING_CHARS[(b8 >> 2) & 0x1f];\n  charCodes[12] = ENCODING_CHARS[((b8 >> 7) | (b7 << 1)) & 0x1f];\n  charCodes[11] = ENCODING_CHARS[((b7 >> 4) | (b6 << 4)) & 0x1f];\n  charCodes[10] = ENCODING_CHARS[(b6 >> 1) & 0x1f];\n  charCodes[9] = ENCODING_CHARS[((b6 >> 6) | (b5 << 2)) & 0x1f];\n  charCodes[8] = ENCODING_CHARS[(b5 >> 3) & 0x1f];\n  charCodes[7] = ENCODING_CHARS[b4 & 0x1f];\n  charCodes[6] = ENCODING_CHARS[((b4 >> 5) | (b3 << 3)) & 0x1f];\n  charCodes[5] = ENCODING_CHARS[(b3 >> 2) & 0x1f];\n  charCodes[4] = ENCODING_CHARS[((b3 >> 7) | (b2 << 1)) & 0x1f];\n  charCodes[3] = ENCODING_CHARS[((b2 >> 4) | (b1 << 4)) & 0x1f];\n  charCodes[2] = ENCODING_CHARS[(b1 >> 1) & 0x1f];\n  charCodes[1] = ENCODING_CHARS[((b1 >> 6) | (b0 << 2)) & 0x1f];\n  charCodes[0] = ENCODING_CHARS[(b0 >> 3) & 0x1f];\n\n  // Convert character codes to string all at once.\n  // This is more efficient than building the string character by character\n  return String.fromCharCode.apply(null, charCodes);\n}\n\n/**\n * Decodes a 20-character base32-hex string to a 12-byte ID.\n *\n * The decoding process maps each character from the base32-hex alphabet\n * back to its 5-bit value, then reassembles these values into the original\n * 12-byte binary format.\n *\n * @param str - The 20-character string to decode\n * @returns The decoded 12-byte buffer\n * @throws Error if the input string is invalid (wrong length or invalid characters)\n */\nexport function decode(str: string): Uint8Array {\n  // Validate input length\n  if (!str || str.length !== ENCODED_LEN) {\n    throw new Error(`Invalid XID length: expected ${ENCODED_LEN}, got ${str?.length || 0}`);\n  }\n\n  // Prepare output buffer\n  const id = new Uint8Array(RAW_LEN);\n\n  // Fast path with direct character code access (unrolled loop)\n  // Optimize by pre-fetching all character codes at once\n  const charCodes = new Uint8Array(ENCODED_LEN);\n  for (let i = 0; i < ENCODED_LEN; i++) {\n    charCodes[i] = str.charCodeAt(i);\n  }\n\n  // Use a try-catch for efficient bounds checking\n  try {\n    // Get decoded values directly (using a typed array for better performance)\n    const decodedValues = new Uint8Array(ENCODED_LEN);\n    for (let i = 0; i < ENCODED_LEN; i++) {\n      const charCode = charCodes[i];\n      const value = DECODING_TABLE[charCode];\n\n      // Fast check for invalid characters\n      if (value === 0xff) {\n        throw new Error(`Invalid character '${str[i]}' at position ${i}`);\n      }\n\n      decodedValues[i] = value;\n    }\n\n    // Unpack 5-bit values to bytes (manually unrolled for performance)\n    // Group by output byte for better readability\n    id[0] = (decodedValues[0] << 3) | (decodedValues[1] >> 2);\n    id[1] = (decodedValues[1] << 6) | (decodedValues[2] << 1) | (decodedValues[3] >> 4);\n    id[2] = (decodedValues[3] << 4) | (decodedValues[4] >> 1);\n    id[3] = (decodedValues[4] << 7) | (decodedValues[5] << 2) | (decodedValues[6] >> 3);\n    id[4] = (decodedValues[6] << 5) | decodedValues[7];\n    id[5] = (decodedValues[8] << 3) | (decodedValues[9] >> 2);\n    id[6] = (decodedValues[9] << 6) | (decodedValues[10] << 1) | (decodedValues[11] >> 4);\n    id[7] = (decodedValues[11] << 4) | (decodedValues[12] >> 1);\n    id[8] = (decodedValues[12] << 7) | (decodedValues[13] << 2) | (decodedValues[14] >> 3);\n    id[9] = (decodedValues[14] << 5) | decodedValues[15];\n    id[10] = (decodedValues[16] << 3) | (decodedValues[17] >> 2);\n    id[11] = (decodedValues[17] << 6) | (decodedValues[18] << 1) | (decodedValues[19] >> 4);\n\n    // Consistency check (verifies that encoding/decoding round trips properly)\n    if (ENCODING[(id[11] << 4) & 0x1f] !== str[19]) {\n      throw new Error('XID consistency check failed');\n    }\n\n    return id;\n  } catch (e) {\n    if (e instanceof Error && e.message.includes('Invalid character')) {\n      throw e; // Rethrow specific validation errors\n    }\n\n    // Handle out-of-bounds errors with more useful information\n    if (e instanceof Error && e.message.includes('out of range')) {\n      // Find which character caused the issue\n      for (let i = 0; i < ENCODED_LEN; i++) {\n        const charCode = charCodes[i];\n        if (charCode >= DECODING_TABLE.length || DECODING_TABLE[charCode] === 0xff) {\n          throw new Error(`Invalid character '${str[i]}' (code ${charCode}) at position ${i}`);\n        }\n      }\n    }\n\n    // Otherwise, wrap the original error\n    throw new Error(`XID decoding error: ${e instanceof Error ? e.message : String(e)}`);\n  }\n}\n", "/**\n * @module nexid/core/xid\n *\n * Core XID immutable value type and operations.\n *\n * ARCHITECTURE:\n * This module provides the fundamental XID implementation - globally unique,\n * lexicographically sortable identifiers with a rich functional API. Each XID\n * consists of 12 bytes (96 bits) with the following structure:\n *\n *   \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n *   \u25510             3\u25514             6\u25517             8\u25519            11\u2551\n *   \u2551--- 4 bytes ---\u2551--- 3 bytes ---\u2551--- 2 bytes ---\u2551--- 3 bytes ---\u2551\n *   \u2551\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2551\n *   \u2551     time      \u2551   machine ID  \u2551   process ID  \u2551    counter    \u2551\n *   \u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n *\n * DESIGN PRINCIPLES:\n * - Immutability: all XID values and operations are immutable\n * - Functional composition: pure operations on value objects\n * - Type safety: comprehensive type definitions with exhaustive checks\n *\n * SECURITY:\n * - Copy-on-read for component extraction to prevent tampering\n * - Strict validation for all inputs\n * - No mutation methods provided on XID instances\n */\n\nimport { ENCODED_LEN, RAW_LEN } from 'nexid/common/constants';\nimport { XIDBytes } from 'nexid/types/xid';\nimport { decode, encode } from './encoding';\n\n/**\n * Immutable XID class representing a globally unique identifier.\n *\n * An XID is a 12-byte value with a specific structure that ensures\n * both uniqueness and lexicographical sortability. XIDs can be\n * serialized to a compact 20-character URL-safe string representation.\n */\nexport class XID {\n  /**\n   * Private constructor to ensure XIDs are only created through factory methods.\n   * This enforces proper validation of all XID instances.\n   *\n   * @param bytes - The underlying byte array for the XID\n   * @private\n   */\n  private constructor(public readonly bytes: XIDBytes) {}\n\n  // ============================================================================\n  // Factory static methods\n  // ============================================================================\n\n  /**\n   * Creates an XID from a raw byte array.\n   *\n   * @param bytes - The 12-byte array to create the ID from\n   * @returns A new XID instance\n   * @throws Error if the input is not a valid 12-byte Uint8Array\n   */\n  public static fromBytes(bytes: Uint8Array): XID {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new Error('ID is not a Uint8Array');\n    }\n    if (bytes.length !== RAW_LEN) {\n      throw new Error('Invalid id length');\n    }\n    return new XID(bytes as XIDBytes);\n  }\n\n  /**\n   * Parses an XID from its 20-character string representation.\n   *\n   * @param str - The string to parse (expected to be 20 characters in base32-hex format)\n   * @returns A new XID instance\n   * @throws Error if the input string is invalid or malformed\n   */\n  public static fromString(str: string): XID {\n    if (str.length !== ENCODED_LEN) {\n      throw new Error('Invalid id length');\n    }\n    if (!/[0-9a-v]{20}/.test(str)) {\n      throw new Error('Invalid string id (must be 20 chars, 0-9 a-v');\n    }\n    return new XID(decode(str) as XIDBytes);\n  }\n\n  /**\n   * Creates a nil (zero) XID, useful as a default value or placeholder.\n   *\n   * @returns A nil XID (all bytes set to zero)\n   */\n  public static nilID(): XID {\n    return new XID(new Uint8Array(RAW_LEN) as XIDBytes);\n  }\n\n  // ============================================================================\n  // Component getters\n  // ============================================================================\n\n  /**\n   * Extracts the timestamp portion of the XID as a JavaScript Date object.\n   *\n   * @returns A Date object representing when the ID was created\n   */\n  get time(): Date {\n    const id = this.bytes;\n    // First 4 bytes contain Unix timestamp (seconds since epoch)\n    const seconds = (id[0] << 24) | (id[1] << 16) | (id[2] << 8) | id[3];\n    return new Date(seconds * 1000);\n  }\n\n  /**\n   * Extracts the machine identifier component from the XID.\n   * This is a 3-byte value derived from platform-specific identifiers.\n   *\n   * @returns A copy of the 3-byte machine ID portion\n   */\n  get machineId(): Uint8Array {\n    return this.bytes.slice(4, 7);\n  }\n\n  /**\n   * Extracts the process ID component from the XID.\n   * This is a 2-byte value of the process that generated the ID.\n   *\n   * @returns A number representing the process ID\n   */\n  get processId(): number {\n    const id = this.bytes;\n    return (id[7] << 8) | id[8];\n  }\n\n  /**\n   * Extracts the counter component from the XID.\n   * This is a 3-byte value that increments for each ID generated by the same\n   * process, ensuring uniqueness even when multiple IDs are generated in the same second.\n   *\n   * @returns A number representing the counter value\n   */\n  get counter(): number {\n    const id = this.bytes;\n    return (id[9] << 16) | (id[10] << 8) | id[11];\n  }\n\n  // ============================================================================\n  // Instance methods\n  // ============================================================================\n\n  /**\n   * Converts the XID to its 20-character base32-hex string representation.\n   * This string is URL-safe, compact, and maintains lexicographical ordering.\n   *\n   * @returns A 20-character string representation of the XID\n   */\n  toString(): string {\n    return encode(this.bytes);\n  }\n\n  /**\n   * Checks if this XID is a nil (zero) ID.\n   * A nil ID has all bytes set to zero and is typically used as a placeholder or default value.\n   *\n   * @returns True if this is a nil ID, false otherwise\n   */\n  isNil(): boolean {\n    return this.bytes.every((byte) => byte === 0);\n  }\n\n  /**\n   * Checks if this XID is equal to another XID.\n   * Two XIDs are equal if they contain the same bytes in the same order.\n   *\n   * @param other - Second XID to compare\n   * @returns True if the XIDs contain identical bytes, false otherwise\n   */\n  equals(other: XID): boolean {\n    if (this === other) return true;\n    return this.bytes.every((byte, i) => byte === other.bytes[i]);\n  }\n}\n", "/**\n * @module nexid/core/counter\n * \n * Atomic counter implementation for thread-safe ID generation.\n * \n * ARCHITECTURE:\n * This module provides a cross-environment atomic counter with several\n * key features:\n * 1. Support for SharedArrayBuffer in modern environments\n * 2. Fallback to WebAssembly shared memory where available\n * 3. Last resort fallback to regular ArrayBuffer for basic environments\n * \n * PERFORMANCE:\n * - Uses native atomic operations for thread safety without locks\n * - Minimal memory overhead with typed arrays\n * - Counter overflow management to prevent duplicate values\n */\n\nimport { CounterValue } from 'nexid/types/xid';\n\n/**\n * Thread-safe counter interface for generating unique, monotonically\n * increasing values.\n */\nexport interface AtomicCounter {\n  /**\n   * Gets the next unique counter value.\n   * \n   * @returns A unique counter value (24-bit integer)\n   */\n  getNext(): CounterValue;\n}\n\n/**\n * Creates an atomic counter with the specified initial seed value.\n * \n * The implementation automatically selects the most appropriate\n * shared memory mechanism for the current runtime environment.\n * \n * @param seed - Initial value for the counter\n * @returns A thread-safe atomic counter\n */\nexport function createAtomicCounter(seed: number): AtomicCounter {\n  let buffer: ArrayBuffer;\n\n  if (globalThis.SharedArrayBuffer) {\n    buffer = new SharedArrayBuffer(4);\n  } else if (globalThis.WebAssembly) {\n    buffer = new WebAssembly.Memory({ initial: 1, maximum: 1, shared: true }).buffer;\n    //                                         \u255A\u2550 1 page = 64KiB\n  } else {\n    buffer = new ArrayBuffer(4);\n  }\n\n  const counter = new Uint32Array(buffer);\n  counter[0] = seed;\n\n  return {\n    getNext(): CounterValue {\n      const value = Atomics.add(counter, 0, 1);\n\n      // Handle overflow\n      if (value === 0) {\n        counter[0] = seed & 0xffff;\n      }\n\n      return (value & 0xffffff) as CounterValue;\n    },\n  };\n}\n", "/**\n * @module nexid/core/xid-generator\n *\n * XID Generator - Core Implementation\n *\n * ARCHITECTURE:\n * This module implements the central ID generation algorithm for NeXID,\n * following the XID specification with custom enhancements for performance\n * and cross-environment compatibility. The generator manages the creation\n * of unique identifiers by combining:\n *\n * 1. Timestamp (4 bytes) - Current time in seconds\n * 2. Machine ID (3 bytes) - Environment-specific identifier\n * 3. Process ID (2 bytes) - Current process or context identifier\n * 4. Counter (3 bytes) - Thread-safe incrementing counter\n *\n * SECURITY:\n * - Uses cryptographically secure random sources when available\n * - Machine IDs are cryptographically hashed to prevent system information disclosure\n * - Random counter initialization to prevent predictable sequences\n *\n * PERFORMANCE:\n * - Pre-allocation of buffer template for minimal GC pressure\n * - Optimized byte manipulation for maximum throughput\n * - Provides fast path for string-only ID generation\n */\n\nimport { BYTE_MASK, RAW_LEN } from 'nexid/common/constants';\nimport { Environment } from 'nexid/env/registry';\nimport { XIDBytes } from 'nexid/types/xid';\nimport { Generator } from 'nexid/types/xid-generator';\nimport { createAtomicCounter } from './counter';\nimport { encode } from './encoding';\nimport { XID } from './xid';\n\n/**\n * Creates an XID generator with the specified environment and options.\n *\n * The generator ensures uniqueness through a combination of timestamp,\n * machine ID, process ID, and atomic counter components.\n *\n * @param env - Environment abstraction providing platform capabilities\n * @param options - Optional configuration parameters\n * @returns Promise resolving to generator API\n */\nexport async function XIDGenerator(\n  env: Environment,\n  options: Generator.Options = {}\n): Promise<Generator.API> {\n  // ==========================================================================\n  // Setup components\n  // ==========================================================================\n  // Resolve capabilities\n  const randomBytes = await env.get('RandomBytes', options.randomBytes || null);\n  const hashFunction = await env.get('HashFunction');\n  const getMachineId = await env.get(\n    'MachineId',\n    options.machineId ? async () => options.machineId as string : null\n  );\n\n  // Use first 3 bytes of machineId hash\n  const machineId = await getMachineId();\n  const machineIdBytes = (await hashFunction(machineId)).subarray(0, 3);\n\n  // Process ID\n  let getProcessId = await env.get(\n    'ProcessId',\n    options.processId ? async () => options.processId as number : null\n  );\n  const processId = (await getProcessId()) & 0xffff;\n\n  // ==========================================================================\n  // Constructor\n  // ==========================================================================\n  /**\n   * Preset constant bytes (machine id & process id) into a base buffer\n   * that will be reused for each XID generation.\n   */\n  const baseBuffer = new Uint8Array(RAW_LEN);\n\n  // Machine ID (3 bytes)\n  baseBuffer[4] = machineIdBytes[0] & BYTE_MASK;\n  baseBuffer[5] = machineIdBytes[1] & BYTE_MASK;\n  baseBuffer[6] = machineIdBytes[2] & BYTE_MASK;\n\n  // Process ID (2 bytes, big endian)\n  baseBuffer[7] = (processId >> 8) & BYTE_MASK;\n  baseBuffer[8] = processId & BYTE_MASK;\n\n  /** Setup atomic counter **/\n  const b1 = randomBytes(3);\n  const b2 = randomBytes(3);\n  const b3 = randomBytes(3);\n  const randomSeed = (b1[0] << 16) | (b2[1] << 8) | b3[2];\n  const counter = createAtomicCounter(randomSeed);\n\n  // ==========================================================================\n  // XID generation\n  // ==========================================================================\n  /**\n   * Builds a new XID byte array with the specified timestamp.\n   *\n   * @param timestamp - Timestamp in milliseconds since epoch\n   * @returns Immutable XID byte array\n   */\n  function buildXIDBytes(timestamp: number): Readonly<XIDBytes> {\n    const buffer = new Uint8Array(baseBuffer);\n\n    // Convert to seconds for the ID (XID spec uses seconds, not milliseconds)\n    timestamp = Math.floor(timestamp / 1000);\n\n    // Timestamp (4 bytes, big endian)\n    buffer[0] = (timestamp >> 24) & BYTE_MASK;\n    buffer[1] = (timestamp >> 16) & BYTE_MASK;\n    buffer[2] = (timestamp >> 8) & BYTE_MASK;\n    buffer[3] = timestamp & BYTE_MASK;\n\n    // Counter (3 bytes, big endian)\n    const currentCounter = counter.getNext();\n    buffer[9] = (currentCounter >> 16) & BYTE_MASK;\n    buffer[10] = (currentCounter >> 8) & BYTE_MASK;\n    buffer[11] = currentCounter & BYTE_MASK;\n\n    return buffer as XIDBytes;\n  }\n\n  // ==========================================================================\n  // Export API\n  // ==========================================================================\n  return {\n    machineId,\n    processId,\n    /**\n     * Generates a new XID with the specified timestamp (defaults to current time).\n     *\n     * @param datetime - Optional date to use instead of current time\n     * @returns A new XID object\n     */\n    newId(datetime?: Date) {\n      const timestamp = datetime instanceof Date ? +datetime : Date.now();\n      return XID.fromBytes(buildXIDBytes(timestamp));\n    },\n\n    /**\n     * Generates a new XID string directly, bypassing object creation.\n     * This is approximately 30% faster than newId() when only the string\n     * representation is needed.\n     *\n     * @returns A string representation of a new XID\n     */\n    fastId() {\n      return encode(buildXIDBytes(Date.now()));\n    },\n  };\n}\n", "/**\n * @module nexid/env/lib/hash-function\n * \n * Cryptographic hash function feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the HashFunction feature,\n * which provides a secure way to hash identifiers before using them in XIDs.\n * Hashing machine IDs and other inputs helps protect sensitive information\n * while still maintaining uniqueness.\n * \n * The hash function should ideally be cryptographically secure whenever possible:\n * - Node.js uses the crypto module's SHA-256 implementation\n * - Browsers use the SubtleCrypto API's SHA-256 implementation\n * - Fallback uses a simple but sufficient non-cryptographic hash function\n * \n * SECURITY:\n * - All platform-specific implementations should use SHA-256 when available\n * - The fallback implementation (FNV-1a) is only used when secure APIs aren't available\n * - Appropriate warnings are displayed when falling back to less secure alternatives\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the HashFunction feature including validation and fallback.\n */\nexport const HashFunctionDefinition: FeatureDefinition<'HashFunction'> = {\n  /**\n   * Tests if the provided implementation is a valid HashFunction function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = await impl('custom-hash-test');\n      return result instanceof Uint8Array && result.length === 32;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Simple fallback hash function when cryptographic APIs are unavailable.\n   * Uses FNV-1a (Fowler\u2013Noll\u2013Vo) hash algorithm which is fast and has\n   * good distribution properties. While not cryptographically secure,\n   * it's sufficient for generating machine IDs.\n   *\n   * SECURITY NOTE: This hash function is NOT cryptographically secure\n   * and should only be used when no secure alternatives are available.\n   *\n   * @param data - String or byte array to hash\n   * @returns A 32-byte hash as a Uint8Array\n   */\n  async fallback(data: string | Uint8Array): Promise<Uint8Array> {\n    console.warn('Using non-secure fallback (hash)');\n\n    // Convert input to string\n    const str = typeof data === 'string' ? data : data.toString();\n\n    // FNV prime: 16777619 (0x01000193)\n    // FNV offset basis: 2166136261 (0x811c9dc5)\n    let h = 0x811c9dc5;\n    for (let i = 0; i < str.length; i++) {\n      h ^= str.charCodeAt(i);\n      h = (h * 0x01000193) >>> 0; // multiply by FNV prime and ensure 32-bit unsigned\n    }\n\n    // Create a result buffer filled with variations of the hash\n    const byteArray = new Uint8Array(32);\n    for (let i = 0; i < 32; i++) {\n      byteArray[i] = ((h ^ (i * 0x53)) + i) & 0xff;\n    }\n\n    return byteArray;\n  },\n};\n", "/**\n * @module nexid/env/lib/machine-id\n * \n * Machine ID feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the MachineId feature,\n * which is responsible for generating a consistent identifier for the current\n * machine/device. This component is critical for ensuring ID uniqueness across\n * different devices in a distributed system.\n * \n * Different platforms expose machine identification in different ways:\n * - Server environments may use MAC addresses, hostname, or OS-specific identifiers\n * - Browsers use fingerprinting techniques while respecting privacy\n * - Mobile devices have their own device identifiers\n * \n * SECURITY:\n * - Machine IDs should be stable but not expose sensitive system information\n * - The machine ID is cryptographically hashed before use in XIDs\n * - Fallback implementation provides uniqueness but with appropriate warnings\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the MachineId feature including validation and fallback.\n */\nexport const MachineIdDefinition: FeatureDefinition<'MachineId'> = {\n  /**\n   * Tests if the provided implementation is a valid MachineId function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = await impl();\n      return !!result && typeof result === 'string' && result.length > 0;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Generates a random machine ID when no hardware identifiers are available.\n   * This fallback uses a combination of timestamp and random values to create\n   * a reasonably unique identifier that won't collide with other instances.\n   *\n   * SECURITY NOTE: This implementation is NOT cryptographically secure\n   * and should not be used for any security-critical purposes.\n   *\n   * @returns A Promise that resolves to a machine identifier string\n   */\n  async fallback(): Promise<string> {\n    console.warn('Using non-secure fallback (machine id)');\n    const timestamp = Date.now().toString(36);\n    const random = () => Math.random().toString(36).substring(2, 10);\n    return `${random()}-${timestamp}-${random()}`;\n  },\n};\n", "/**\n * @module nexid/env/lib/process-id\n * \n * Process ID feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the ProcessId feature,\n * which provides a stable identifier for the current process or execution context.\n * This component helps ensure uniqueness of XIDs generated within the same machine\n * but by different processes or contexts.\n * \n * Different runtimes have different concepts of \"process\":\n * - Node.js has actual process IDs from the operating system\n * - Browsers use tab/window IDs or random values that are stable during a session\n * - Workers and service workers track their context IDs\n * \n * The process ID is a 2-byte value in the XID, allowing for up to 65,535 unique\n * processes or contexts on a single machine without risk of collisions.\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the ProcessId feature including validation and fallback.\n */\nexport const ProcessIdDefinition: FeatureDefinition<'ProcessId'> = {\n  /**\n   * Tests if the provided implementation is a valid ProcessId function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = await impl();\n      return typeof result === 'number' && result > 0;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Generates a random process ID when process information is unavailable.\n   * This ensures IDs can still be generated with some level of uniqueness.\n   *\n   * @returns A Promise that resolves to a randomly generated process ID\n   */\n  async fallback(): Promise<number> {\n    console.warn('Using non-secure fallback (process id)');\n    // Generate a random number between 1 and 65535 (0xFFFF)\n    return Math.floor(Math.random() * 0xffff) + 1;\n  },\n};\n", "/**\n * @module nexid/env/lib/random-bytes\n * \n * Random bytes feature definition and fallback implementation.\n * \n * ARCHITECTURE:\n * This module defines the interface and validation for the RandomBytes feature,\n * which is responsible for generating cryptographically secure random values.\n * The feature is critical for the security of generated IDs, as it provides\n * the unpredictable component that prevents ID collisions and guessing.\n * \n * SECURITY:\n * - Defines test function to validate that implementations produce proper output\n * - Provides a non-secure fallback using Math.random() with appropriate warnings\n * - Platform-specific implementations should use the best available source of entropy\n */\n\nimport { FeatureDefinition } from 'nexid/env/registry';\n\n/**\n * Definition of the RandomBytes feature including validation and fallback.\n */\nexport const RandomBytesDefinition: FeatureDefinition<'RandomBytes'> = {\n  /**\n   * Tests if the provided implementation is a valid RandomBytes function.\n   * \n   * @param impl - The implementation to test\n   * @returns Promise resolving to true if the implementation is valid\n   */\n  async test(impl: unknown): Promise<boolean> {\n    if (typeof impl !== 'function') return false;\n    try {\n      const result = impl(5);\n      return result instanceof Uint8Array && result.length === 5;\n    } catch {\n      return false;\n    }\n  },\n\n  /**\n   * Fallback random source that uses Math.random().\n   * WARNING: This is NOT cryptographically secure and should only be used\n   * when no secure alternatives are available.\n   *\n   * @param size - Number of random bytes to generate\n   * @returns Uint8Array of pseudo-random values\n   */\n  fallback(size: number): Uint8Array {\n    console.warn('Using non-secure fallback (randomBytes)');\n\n    const byteArray = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n      byteArray[i] = Math.floor(Math.random() * 256);\n    }\n    return byteArray;\n  },\n};\n", "/**\n * @module nexid/env/registry\n *\n * Environment features registry and resolution system.\n *\n * ARCHITECTURE:\n * This module implements a capability-based environment abstraction layer\n * that enables the library to adapt to different JavaScript runtimes while\n * providing a consistent API. The registry:\n *\n * 1. Defines the core capabilities required by the ID generator\n * 2. Manages the validation and fallback mechanisms for these capabilities\n * 3. Implements a resolution system with caching for performance\n *\n * This abstraction allows the core library code to remain platform-agnostic\n * while still utilizing environment-specific optimizations when available.\n */\n\nimport { HashFunctionDefinition } from './lib/hash-function/@definition';\nimport { MachineIdDefinition } from './lib/machine-id/@definition';\nimport { ProcessIdDefinition } from './lib/process-id/@definition';\nimport { RandomBytesDefinition } from './lib/random-bytes/@definition';\n\n// ============================================================================\n// Types\n// ============================================================================\n/**\n * Core capabilities required by the XID generator.\n * Each capability is implemented differently based on the runtime environment.\n */\nexport type FeatureSet = {\n  /** Generates cryptographically secure random bytes */\n  RandomBytes: (size: number) => Uint8Array;\n\n  /** Creates a cryptographic hash of input data */\n  HashFunction: (data: string | Uint8Array) => Promise<Uint8Array>;\n\n  /** Provides a stable machine/device identifier */\n  MachineId: () => Promise<string>;\n\n  /** Provides a process-specific identifier */\n  ProcessId: () => Promise<number>;\n};\n\nexport type Feature = keyof FeatureSet;\nexport type FeatureValidator = (impl: unknown) => Promise<boolean>;\n\n/**\n * Definition of a feature including its validation function and fallback implementation.\n */\nexport type FeatureDefinition<F extends Feature> = {\n  test: FeatureValidator;\n  fallback: FeatureSet[F];\n};\n\n/**\n * Platform-specific adapter providing implementations for all required features.\n */\nexport type EnvironmentAdapter = {\n  [F in keyof FeatureSet]: FeatureSet[F];\n};\n\ntype Registry = {\n  [F in keyof FeatureSet]: FeatureDefinition<F>;\n};\n\n// ============================================================================\n// Registry\n// ============================================================================\n/**\n * Global registry of all feature definitions.\n */\nexport const REGISTRY: Registry = {\n  RandomBytes: RandomBytesDefinition,\n  HashFunction: HashFunctionDefinition,\n  MachineId: MachineIdDefinition,\n  ProcessId: ProcessIdDefinition,\n};\n\n/**\n * Environment class that manages feature resolution and caching.\n */\nexport class Environment {\n  private cache: Map<Feature, FeatureSet[Feature]> = new Map();\n\n  constructor(private adapter: EnvironmentAdapter) {}\n\n  /**\n   * Resolves a specific feature implementation, prioritizing:\n   * 1. A provided candidate implementation (if valid)\n   * 2. Previously cached implementation\n   * 3. Adapter-provided implementation\n   * 4. Fallback implementation as a last resort\n   *\n   * @param feature - The capability to resolve\n   * @param candidate - Optional custom implementation to use if valid\n   * @returns Promise resolving to the best available implementation\n   */\n  async get<F extends Feature>(\n    feature: F,\n    candidate?: FeatureSet[F] | null\n  ): Promise<FeatureSet[F]> {\n    const featureDefinition = REGISTRY[feature];\n\n    if (candidate && (await featureDefinition.test(candidate))) {\n      console.log(`NeXID: using user's provided ${feature}: ${candidate}`);\n      this.cache.set(feature, candidate);\n      return candidate;\n    }\n\n    if (this.cache.has(feature)) {\n      return this.cache.get(feature) as FeatureSet[F];\n    }\n\n    const adapterFeature = this.adapter[feature];\n    if (await featureDefinition.test(adapterFeature)) {\n      console.log(`NeXID: using adapter's implementation of ${feature}`);\n      this.cache.set(feature, adapterFeature);\n      return adapterFeature;\n    }\n\n    // Fallback\n    console.log(`NeXID: using fallback ${feature}`);\n    return featureDefinition.fallback;\n  }\n}\n"],
  "mappings": "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",
  "names": ["randomBytes", "getProcessId"]
}
